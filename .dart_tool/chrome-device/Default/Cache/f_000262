define(['dart_sdk', 'packages/flutter_wgl/src/core/lib.dart', 'packages/vector_math/vector_math.dart'], (function load__packages__flutter_wgl__src__shader__lib_dart(dart_sdk, packages__flutter_wgl__src__core__lib$46dart, packages__vector_math__vector_math$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const math = dart_sdk.math;
  const _interceptors = dart_sdk._interceptors;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const lib = packages__flutter_wgl__src__core__lib$46dart.src__core__lib;
  const vector_math = packages__vector_math__vector_math$46dart.vector_math;
  var lib$ = Object.create(dart.library);
  var $add = dartx.add;
  var $_get = dartx._get;
  dart._checkModuleNullSafetyMode(false);
  var T = {
    doubleL: () => (T.doubleL = dart.constFn(dart.legacy(core.double)))(),
    JSArrayOfdoubleL: () => (T.JSArrayOfdoubleL = dart.constFn(_interceptors.JSArray$(T.doubleL())))(),
    StringL: () => (T.StringL = dart.constFn(dart.legacy(core.String)))(),
    JSArrayOfStringL: () => (T.JSArrayOfStringL = dart.constFn(_interceptors.JSArray$(T.StringL())))(),
    ShaderObjectL: () => (T.ShaderObjectL = dart.constFn(dart.legacy(lib.ShaderObject)))(),
    JSArrayOfShaderObjectL: () => (T.JSArrayOfShaderObjectL = dart.constFn(_interceptors.JSArray$(T.ShaderObjectL())))()
  };
  var T$Eval = Object.assign({
    _: () => T$Eval
  }, T);
  var S = {
    _: () => S
  };
  var S$Eval = Object.assign({
    _: () => S$Eval
  }, S);
  const CT = Object.create({
    _: () => (C, CT)
  });
  var C = [];
  var I = [];
  lib$._gaussianPdf = function _gaussianPdf(x, sigma) {
    return 0.39894 * math.exp(-0.5 * dart.notNull(x) * dart.notNull(x) / (dart.notNull(sigma) * dart.notNull(sigma))) / dart.notNull(sigma);
  };
  lib$.makeGaussianPdfKernelString = function makeGaussianPdfKernelString(radius, sigma) {
    let w = T.JSArrayOfdoubleL().of([]);
    let total = 0.0;
    for (let i = 0; i < dart.notNull(radius); i = i + 1) {
      let x = lib$._gaussianPdf(i * 1.0, sigma);
      w[$add](x);
      total = total + dart.notNull(x);
      if (i > 0) total = total + dart.notNull(x);
    }
    let sb = new core.StringBuffer.new("");
    let sep = "";
    for (let i = 0; i < dart.notNull(radius); i = i + 1) {
      sb.write(sep);
      sep = ", ";
      sb.write(dart.str(dart.notNull(w[$_get](i)) / total));
    }
    return "float kernel[" + dart.str(radius) + "] = float[" + dart.str(radius) + "](" + dart.str(sb.toString()) + ");";
  };
  lib$.CreateBloomTextureFragmentShader = function CreateBloomTextureFragmentShader(radius, sigma) {
    let t0;
    let constants = lib$.makeGaussianPdfKernelString(radius, sigma);
    t0 = new lib.ShaderObject.new("BloomPassF");
    return (() => {
      t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
      t0.AddUniformVars(T.JSArrayOfStringL().of(["uDirection", "uTexture"]));
      t0.SetBody(T.JSArrayOfStringL().of([constants, lib$._kernelFragment]));
      return t0;
    })();
  };
  lib$.CrosshatchFragmentShader = function CrosshatchFragmentShader(mode) {
    let t0;
    t0 = new lib.ShaderObject.new("crosshatchPixelateF");
    return (() => {
      t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture"]));
      t0.SetBody(T.JSArrayOfStringL().of(["#define MODE " + dart.str(mode), "float level1 = 1.0;\nfloat level2 = 0.7;\nfloat level3 = 0.5;\nfloat level4 = 0.3;\n\nfloat dist = 10.0;\nfloat thickness = 0.5;\n\n#if MODE == 0\n// diagonal crosshach\nvec2 slope = vec2(1.0, 1.0);\n#elif MODE == 1\n// regular crosshatch\nvec2 slope = vec2(1.0, 0.0);\n#else\nERROR\n#endif\n\nfloat PixelColor(vec2 pixel, float lum) {\n    if (lum < level1) {\n        // main anti diagonal\n        if (mod(pixel.x * slope.x + pixel.y * slope.y, dist) <= thickness) return 0.0; \n    }  \n  \n    if (lum < level2) { \n        // main diagonal\n        if (mod(pixel.x * slope.y - pixel.y * slope.x, dist) <= thickness) return 0.0;\n    }  \n  \n    if (lum < level3) {\n        // inbetween anti diagonals\n        if (mod(pixel.x * slope.x + pixel.y * slope.y - dist * 0.5, dist) <= thickness) return 0.0;\n    }  \n  \n    if (lum < level4) {\n        // inbetween main diagonals\n        if (mod(pixel.x * slope.y - pixel.y * slope.x - dist * 0.5, dist) <= thickness) return 0.0;\n    } \n    \n    return 1.0;\n}       \n       \nvoid main()  { \n    vec2 pixel = gl_FragCoord.xy;  // this is really pixel + 0.5\n   \n    float lum = dot(vec3(0.2126, 0.7152, 0.0723), \n                    texelFetch(" + "uTexture" + ", ivec2(pixel), 0).rgb);\n    \n    float color = PixelColor(pixel, lum);\n    " + "oFragColor" + " = vec4(vec3(color), 1.0);  \n}      \n\n"]));
      return t0;
    })();
  };
  lib$.makePerlinNoiseColorFragmentShader = function makePerlinNoiseColorFragmentShader(blackVariant) {
    let t0;
    let define = "";
    let name = "PerlinNoiseColor";
    if (dart.test(blackVariant)) {
      define = "#define BLACK 1";
      name = "Black" + name;
    }
    t0 = new lib.ShaderObject.new(name + " F");
    return (() => {
      t0.AddVaryingVars(T.JSArrayOfStringL().of(["vNormal"]));
      t0.AddUniformVars(T.JSArrayOfStringL().of(["uTime", "uTransformationMatrix"]));
      t0.SetBody(T.JSArrayOfStringL().of([define, lib$.PerlinNoiseFunctions, "#define VARIANT 1\n\nvoid main() {\n#if VARIANT == 1\n  float mytime = " + "uTime" + "/2.0;\n#ifdef BLACK\n  mytime = " + "uTime" + "/10.0;\n#endif\n  float period = 10.0;\n  float factor = 1.0; // sin( " + "uTime" + ")/4.0+2.0;\n  vec3 translation = " + "uTransformationMatrix" + "[3].xyz;\n  float r = pnoise( .75 * ( " + "vNormal" + " *factor + mytime ), vec3( period ) );\n  float g = pnoise( 0.8 * ( " + "vNormal" + " *factor + mytime ), vec3( period ) );\n  float b = pnoise( 0.9 * ( " + "vNormal" + " *factor + mytime ), vec3( period ) );\n  float n = pnoise( 1.5 * ( " + "vNormal" + " *factor + mytime ), vec3( period ) );\n#else\n  float mytime = 0.0 ; //" + "uTime" + "/50.0;\n  float period = 5.0;\n  float factor = 1.0; // sin( " + "uTime" + ")/4.0+2.0;\n  vec3 translation = " + "uTransformationMatrix" + "[3].xyz;\n  float r = pnoise( .75 * ( translation*0.175 + " + "vNormal" + " *factor + mytime ), vec3( period ) );\n  float g = pnoise( 0.8 * ( translation*0.175 + " + "vNormal" + " *factor + mytime ), vec3( period ) );\n  float b = pnoise( 0.9 * ( translation*0.175 + " + "vNormal" + " *factor + mytime ), vec3( period ) );\n  float n = pnoise( 1.5 * ( translation*0.175 + " + "vNormal" + " *factor + mytime ), vec3( period ) );\n#endif\n\n  n = pow( .001, n );\n//float n = 10.0 * pnoise( 5.0 * ( " + "vNormal" + " + " + "uTime" + " ), vec3( 10.0 ) ) * pnoise( .5 * ( " + "vNormal" + " + " + "uTime" + " ), vec3( 10.0 ) );\n//n += .5 * pnoise( 4.0 * " + "vNormal" + ", vec3( 10.0 ) );\n#ifdef BLACK\n  vec3 color = vec3( 1.0-(r + n), 1.0-(g + n), 1.0-(b + n) );\n#else\n  vec3 color = vec3( (r + n), (g + n), (b + n) );\n#endif\n  " + "oFragColor" + " = vec4( color, 1.0 );\n}\n"]));
      return t0;
    })();
  };
  lib$.createPlane2GreyShader = function createPlane2GreyShader() {
    let t0, t0$;
    return T.JSArrayOfShaderObjectL().of([(t0 = new lib.ShaderObject.new("Plane2GreyV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aNormal"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["float d = sin(dot( " + "aPosition" + ", " + "aNormal" + ")) / 2.0 + 0.5;", "vColor" + " = vec3(d,d,d);", lib$.StdVertexBody]));
        return t0;
      })()), (t0$ = new lib.ShaderObject.new("Plane2GreyF"), (() => {
        t0$.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0$.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = vec4(" + "vColor" + ", 1.0);"]));
        return t0$;
      })())]);
  };
  lib$.createPlane2ColorShader = function createPlane2ColorShader() {
    let t0, t0$;
    return T.JSArrayOfShaderObjectL().of([(t0 = new lib.ShaderObject.new("Plane2ColorV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aNormal"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$._VertexShaderPlane2ColorV]));
        return t0;
      })()), (t0$ = new lib.ShaderObject.new("Plane2ColorF"), (() => {
        t0$.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0$.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = vec4( vColor, 1.0 );"]));
        return t0$;
      })())]);
  };
  dart.defineLazy(lib$, {
    /*lib$.StdVertexBody*/get StdVertexBody() {
      return "gl_Position = uPerspectiveViewMatrix * uModelMatrix * vec4(aPosition, 1.0);";
    },
    /*lib$.StdVertexNormalForward*/get StdVertexNormalForward() {
      return "vNormal = uNormalMatrix * aNormal;";
    },
    /*lib$.NullVertexShaderString*/get NullVertexShaderString() {
      return "void main() {\n  gl_Position = vec4(aPosition, 1.0);\n}\n";
    },
    /*lib$.NullVertexShaderWithTextureForwardString*/get NullVertexShaderWithTextureForwardString() {
      return "void main() {\n  gl_Position = vec4(aPosition, 1.0);\n  vTexUV = aTexUV;\n}\n";
    },
    /*lib$.StdVertexShaderWithTextureForwardString*/get StdVertexShaderWithTextureForwardString() {
      return "void main() {\n  gl_Position = uPerspectiveViewMatrix * \n                uModelMatrix * \n                vec4(aPosition, 1.0);\n  vTexUV = aTexUV;\n}\n";
    },
    /*lib$.StdLibShader*/get StdLibShader() {
      return "// ============================================================\n// MISC\n// ============================================================\n\nvec3 ColorFromPosition(vec3 pos) {\n    return vec3( sin(pos.x) / 2.0 + 0.5,\n                 cos(pos.y) / 2.0 + 0.5,\n                 sin(pos.z) / 2.0 + 0.5);\n}\n\nvec3 RangeToGray(float f, float a, float b) {\n    if (f > a) return vec3(1.0);\n    if (f < b) return vec3(0.0);\n    return vec3 ((f - b) / (a-b));\n}\n\nfloat useValueButReturnZero(float x) {\n    return (x + 1.0) * (x + 1.0) - x * x - 2.0 * x - 1.0;\n}\n\n// ============================================================\n// LIGHT\n// ============================================================\n\nfloat GetDiffuse(vec3 lightDir, vec3 normal) {\n    return max(dot(normal, lightDir), 0.0);\n}\n\nfloat GetSpecular(vec3 lightDir, vec3 viewDir, vec3 normal, float glossiness) {\n    vec3 angleW = normalize(viewDir + lightDir);\n    float specComp = max(0., dot(normal, angleW));\n    return pow(specComp, max(1.0, glossiness));\n}\n\nstruct ColorComponents {\n   vec3 diffuse;\n   vec3 specular;\n};\n\n// ============================================================\n// Spot Light\n// ============================================================\n\nstruct SpotLightInfo {\n    vec3 pos;      // for spot and point\n    vec3 dir;      // for spot and dir light\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float range;        // for spot and point\n    float spotCutoff;   // for spot\n    float spotFocus;    // for spot\n    // float glossiness;   // Oddball: this comes from the material\n};\n\nSpotLightInfo UnpackSpotLightInfo(mat4 m) {\n    SpotLightInfo info;\n    info.pos = m[0].xyz;\n    info.dir = normalize(m[1].xyz);\n    info.diffuseColor = m[2].xyz;\n    info.specularColor = m[3].xyz;\n    // info.glossiness = m[0].a;\n    info.range = m[1].a;\n    info.spotCutoff = m[2].a;\n    info.spotFocus = m[3].a;\n    return info;\n}\n\nColorComponents SpotLightGetDiffuseAndSpecular(SpotLightInfo light,\n                                               vec3 vertexPos,\n                                               vec3 vertexNormal,\n                                               vec3 eyePos,\n                                               float uShininess) {\n    vec3 toSpot = light.pos - vertexPos;\n    vec3 spotDir = normalize(toSpot);\n    vec3 lightDirNorm = -normalize(light.dir);\n    float cosAngle = max(0., dot(lightDirNorm, spotDir));\n\t  if (cosAngle < light.spotCutoff) {\n        return ColorComponents(vec3(0.0), vec3(0.0));\n    }\n\n    cosAngle = max(0.0, pow(cosAngle, light.spotFocus));\n\t  float attenuation = max(0.0, 1.0 - length(toSpot) / light.range) * cosAngle;\n\t  vec3 viewDirNorm = normalize(eyePos - vertexPos);\n\t  return ColorComponents(\n\t           attenuation *\n             GetDiffuse(lightDirNorm, vertexNormal) *\n             light.diffuseColor,\n             attenuation *\n             GetSpecular(lightDirNorm, viewDirNorm, vertexNormal, uShininess) *\n             light.specularColor);\n}\n\n// ============================================================\n// Point Light\n// ============================================================\n\nstruct PointLightInfo {\n    vec3 pos;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float range;\n    // float glossiness;\n};\n\nPointLightInfo UnpackPointLightInfo(mat4 m) {\n    PointLightInfo info;\n    info.pos = m[0].xyz;\n    info.diffuseColor = m[2].xyz;\n    info.specularColor = m[3].xyz;\n    info.range = m[1].a;\n    // info.glossiness = m[0].a;\n    return info;\n}\n\nColorComponents PointLightGetDiffuseAndSpecular(PointLightInfo info,\n                                     vec3 vertexPos,\n                                     vec3 vertexNormal,\n                                     vec3 eyePos,\n                                     float uShininess) {\n    vec3 lightDir = info.pos - vertexPos;\n    float attenuation = max(0.0, 1.0 - length(lightDir) / info.range);\n    vec3 lightDirNorm = normalize(lightDir);\n    vec3 viewDirNorm = normalize(eyePos - vertexPos);\n    return ColorComponents(\n              attenuation *\n              GetDiffuse(lightDirNorm, vertexNormal) *\n              info.diffuseColor,\n               attenuation *\n               GetSpecular(lightDirNorm, viewDirNorm, vertexNormal, uShininess) *\n               info.specularColor);\n}\n\n// ============================================================\n// Directional Light\n// ============================================================\n\nstruct DirectionalLightInfo {\n    vec3 dir;      // for spot and dir light\n    vec3 diffuseColor;\n    vec3 specularColor;\n    // float glossiness;   // Oddball: this comes from the material\n};\n\nDirectionalLightInfo UnpackDirectionalLightInfo(mat4 m) {\n    DirectionalLightInfo info;\n    info.dir = normalize(m[1].xyz);\n    info.diffuseColor = m[2].xyz;\n    info.specularColor = m[3].xyz;\n    // info.glossiness = m[0].a;\n    return info;\n}\n\nColorComponents DirectionalLightGetDiffuseAndSpecular(DirectionalLightInfo info,\n                                                      vec3 vertexPos,\n                                                      vec3 vertexNormal,\n                                                      vec3 eyePos,\n                                                      float uShininess) {\n    vec3 viewDirNorm = normalize(eyePos - vertexPos);\n    return ColorComponents(\n              GetDiffuse(-info.dir, vertexNormal) *\n              info.diffuseColor,\n              GetSpecular(-info.dir, viewDirNorm, vertexNormal, uShininess) *\n              info.specularColor);\n}\n\n\nColorComponents CombinedLightSpot(\n    vec3 vVertexPosition, vec3 vNormal, vec3 uEyePosition, mat4 lightDesc,\n    float shininess) {\n    SpotLightInfo info = UnpackSpotLightInfo(lightDesc);\n    return SpotLightGetDiffuseAndSpecular(\n        info, vVertexPosition, vNormal, uEyePosition, shininess);\n}\n\nColorComponents CombinedLightPoint(\n    vec3 vVertexPosition, vec3 vNormal, vec3 uEyePosition, mat4 lightDesc,\n    float shininess) {\n    PointLightInfo info = UnpackPointLightInfo(lightDesc);\n    return PointLightGetDiffuseAndSpecular(\n        info, vVertexPosition, vNormal, uEyePosition, shininess);\n}\n\nColorComponents CombinedLightDirectional(\n    vec3 vVertexPosition, vec3 vNormal, vec3 uEyePosition, mat4 lightDesc,\n    float shininess) {\n    DirectionalLightInfo info = UnpackDirectionalLightInfo(lightDesc);\n    return DirectionalLightGetDiffuseAndSpecular(\n        info, vVertexPosition, vNormal, uEyePosition, shininess);\n}\n\n// ============================================================\n// Combined Light\n// ============================================================\nColorComponents CombinedLight(vec3 vVertexPosition,\n                   vec3 vNormal,\n                   vec3 uEyePosition,\n                   const mat4 uLightDescs[4],\n                   const float uLightTypes[4],\n                   float uShininess) {\n    ColorComponents acc = ColorComponents(vec3(0.0), vec3(0.0));\n\n    for (int i = 0; i < 4; ++i) {\n        ColorComponents curr;\n        float type = uLightTypes[i];\n        if (type == 2.0) {\n            curr = CombinedLightSpot(\n                       vVertexPosition, vNormal, uEyePosition, uLightDescs[i], \n                       uShininess);\n        } else if (type == 3.0) {\n            curr = CombinedLightPoint(\n                       vVertexPosition, vNormal, uEyePosition, uLightDescs[i], \n                       uShininess);\n        } else if (type == 1.0) {\n            curr = CombinedLightDirectional(\n                       vVertexPosition, vNormal, uEyePosition, uLightDescs[i], \n                       uShininess);\n        } else {\n            continue;\n        }\n        acc.diffuse = acc.diffuse + curr.diffuse;\n        acc.specular = acc.specular + curr.specular;\n    }\n    return acc;\n}\n";
    },
    /*lib$.StdLibShaderDerivative*/get StdLibShaderDerivative() {
      return "vec2 dHdxy_fwd(vec2 uv, float scale, sampler2D map) {\n    float H = texture(map, uv).x;\n    float dHx = texture(map, uv + dFdx(uv)).x - H;\n    float dHy = texture(map, uv + dFdy(uv)).x - H;\n    return vec2(dHx, dHy) * scale;\n}\n\n\nvec3 perturbNormalArb(vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n     vec3 vSigmaX = dFdx(surf_pos);\n     vec3 vSigmaY = dFdy(surf_pos);\n        \n     vec3 vN = surf_norm;\n     vec3 R1 = cross(vSigmaY, vN);\n     vec3 R2 = cross(vN, vSigmaX);\n     float fDet = dot(vSigmaX, R1);\n     // *= gl_FrontFacing ? 1.0 : -1.0\n     fDet *= (float(gl_FrontFacing) * 2.0 - 1.0);\n     vec3 vGrad = sign(fDet) * (dHdxy.x * R1 + dHdxy.y * R2);\n     return normalize(abs(fDet) * surf_norm - vGrad);\n}\n";
    },
    /*lib$.PackedRGBALib*/get PackedRGBALib() {
      return "// r,g,b,a  are in the range of [0, 254]\n// float = r / 255^1 + g / 255^2 + b / 255^3 + a / 255^4\n// float is assumed to be in [0, 1]\n// Not that the conversion from bytes to floats introduces a 1/255 factor\n// Inspired by http://spidergl.org/example.php?id=6\n\n// 256.0 does not work quite as well.\nconst float _b = 255.0;\nconst vec4 _shift = vec4(1.0, _b, _b * _b, _b * _b * _b);\nconst vec4 _shiftInv = vec4(1.0, 1.0 / _b, 1.0 / (_b * _b), 1.0 / (_b * _b * _b));\n\nvec4 packDepth(float depth) {\n\t  vec4 res = fract(depth * _shift);\n    // the next three correction terms can probably be omitted if we\n    // know for sure that we are dealing with 8 bits per color component\n    res.r -= res.g / _b;\n    res.g -= res.b / _b;\n    res.b -= res.a / _b;\n\t  return res;\n}\n\n\nfloat unpackDepth(vec4 rgba_depth) {\n\t  return dot(rgba_depth, _shiftInv);\n}\n\n";
    },
    /*lib$.texturedVertexShader*/get texturedVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("Textured"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aTexUV"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.StdVertexShaderWithTextureForwardString]));
        return t0;
      })();
    },
    /*lib$.texturedFragmentShader*/get texturedFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("TexturedF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uColor", "uTexture"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = texture(" + "uTexture" + ", " + "vTexUV" + ") + vec4( " + "uColor" + ", 0.0 );"]));
        return t0;
      })();
    },
    /*lib$.solidColorVertexShader*/get solidColorVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("SolidColor"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of([lib$.StdVertexBody]));
        return t0;
      })();
    },
    /*lib$.solidColorFragmentShader*/get solidColorFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("SolidColorF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uColor"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = vec4( " + "uColor" + ", 1.0 );"]));
        return t0;
      })();
    },
    /*lib$.cubeMapVertexShader*/get cubeMapVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("CubeMap"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vPosition"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of([lib$.StdVertexBody, "vPosition" + " = normalize(" + "aPosition" + ");"]));
        return t0;
      })();
    },
    /*lib$.cubeMapFragmentShader*/get cubeMapFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("CubeMapF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vPosition"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uCubeTexture"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = texture( " + "uCubeTexture" + ", " + "vPosition" + " );"]));
        return t0;
      })();
    },
    /*lib$.pointSpritesVertexShader*/get pointSpritesVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("PointSpritesV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix", "uPointSize"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of([lib$.StdVertexBody, "gl_PointSize = " + "uPointSize" + "/gl_Position.z;"]));
        return t0;
      })();
    },
    /*lib$.pointSpritesFragmentShader*/get pointSpritesFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("PointSpritesF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = texture( " + "uTexture" + ",  gl_PointCoord);"]));
        return t0;
      })();
    },
    /*lib$.demoVertexShader*/get demoVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("FixedVertexColorV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of([lib$.StdVertexBody, "vColor" + " = ColorFromPosition(" + "aPosition" + ");"]), {prolog: T.JSArrayOfStringL().of([lib$.StdLibShader])});
        return t0;
      })();
    },
    /*lib$.demoFragmentShader*/get demoFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("FixedVertexColorF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = vec4( " + "vColor" + ", 1.0 );"]));
        return t0;
      })();
    },
    /*lib$.multiColorVertexShader*/get multiColorVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("MultiColorVertexColorV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aColor"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of([lib$.StdVertexBody, "vColor" + " = " + "aColor" + ";"]), {prolog: T.JSArrayOfStringL().of([lib$.StdLibShader])});
        return t0;
      })();
    },
    /*lib$.multiColorFragmentShader*/get multiColorFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("MultiColorVertexColorF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = vec4( " + "vColor" + ", 1.0 );"]));
        return t0;
      })();
    },
    /*lib$.lightVertexShaderGourad*/get lightVertexShaderGourad() {
      let t0;
      return t0 = new lib.ShaderObject.new("LightGouradV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aNormal", "aTexUV"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix", "uNormalMatrix"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uLightDescs", "uLightTypes", "uShininess"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uEyePosition", "uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of(["void main() {\n    vec4 pos = " + "uModelMatrix" + " * vec4(" + "aPosition" + ", 1.0);\n    gl_Position = " + "uPerspectiveViewMatrix" + " * pos;\n    vec3 normal = " + "uNormalMatrix" + " * " + "aNormal" + ";\n\n    ColorComponents acc = CombinedLight(pos.xyz, normal, " + "uEyePosition" + ",\n                  " + "uLightDescs" + ",\n                  " + "uLightTypes" + ",\n                  " + "uShininess" + ");\n\n     " + "vColor" + " = acc.diffuse +\n                 acc.specular +\n                 texture(" + "uTexture" + ", " + "aTexUV" + ").rgb;\n}\n        "]), {prolog: T.JSArrayOfStringL().of([lib$.StdLibShader])});
        return t0;
      })();
    },
    /*lib$.lightFragmentShaderGourad*/get lightFragmentShaderGourad() {
      let t0;
      return t0 = new lib.ShaderObject.new("LightGrouradV"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vColor"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = vec4(" + "vColor" + ", 1.0 );"]));
        return t0;
      })();
    },
    /*lib$.lightVertexShaderBlinnPhong*/get lightVertexShaderBlinnPhong() {
      let t0;
      return t0 = new lib.ShaderObject.new("LightBlinnPhongV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aNormal", "aTexUV"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vPosition", "vNormal", "vTexUV"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix", "uNormalMatrix"]));
        t0.SetBody(T.JSArrayOfStringL().of(["void main() {\n    vec4 pos = " + "uModelMatrix" + " * vec4(" + "aPosition" + ", 1.0);\n    gl_Position = " + "uPerspectiveViewMatrix" + " * pos;\n    " + "vPosition" + " = pos.xyz;\n    " + "vTexUV" + " = " + "aTexUV" + ";\n    " + "vNormal" + " = " + "uNormalMatrix" + " * " + "aNormal" + ";\n}\n"]));
        return t0;
      })();
    },
    /*lib$.lightFragmentShaderBlinnPhong*/get lightFragmentShaderBlinnPhong() {
      let t0;
      return t0 = new lib.ShaderObject.new("LightBlinnPhongF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vPosition", "vNormal", "vTexUV"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uLightDescs", "uLightTypes", "uShininess"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uEyePosition", "uTexture"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["ColorComponents acc = CombinedLight(" + "vPosition" + ",\n                                    " + "vNormal" + ",\n                                    " + "uEyePosition" + ",\n                                    " + "uLightDescs" + ",\n                                    " + "uLightTypes" + ",\n                                    " + "uShininess" + ");\n\n" + "oFragColor" + ".rgb = acc.diffuse +\n                    acc.specular +\n                    texture(" + "uTexture" + ", " + "vTexUV" + ").rgb;\n" + "oFragColor" + ".a = 1.0;\n"]), {prolog: T.JSArrayOfStringL().of([lib$.StdLibShader])});
        return t0;
      })();
    },
    /*lib$._kernelFragment*/get _kernelFragment() {
      return "void main() {\n    vec2 invSize = 1.0 / vec2(textureSize(uTexture, 0));\n    vec3 sum = texture(uTexture, vTexUV).rgb * kernel[0];\n    for (int i = 1; i < kernel.length(); i++) {\n        vec2 offset = uDirection * invSize * float(i);\n        sum += texture(uTexture, vTexUV + offset).rgb * kernel[i];\n        sum += texture(uTexture, vTexUV - offset).rgb * kernel[i];\n    }\n    oFragColor = vec4(sum, 1.0);\n}\n";
    },
    /*lib$.uvPassthruVertexShader*/get uvPassthruVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("uv-passthru"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aTexUV"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.NullVertexShaderWithTextureForwardString]));
        return t0;
      })();
    },
    /*lib$.applyBloomEffectFragmentShader*/get applyBloomEffectFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("BloomPassF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uTexture2", "uScale", "uColor"]));
        t0.SetBody(T.JSArrayOfStringL().of(["void main() {\n\t" + "oFragColor" + " = texture(" + "uTexture" + ", " + "vTexUV" + ") +\n\t                " + "uScale" + " *\n\t                vec4(" + "uColor" + ", 1.0) *\n\t                texture(" + "uTexture2" + ", " + "vTexUV" + ");\n}\n"]));
        return t0;
      })();
    },
    /*lib$.scaledLuminosityHighPassFragmentShader*/get scaledLuminosityHighPassFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("ScaledLuminosityHighPassF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uRange", "uColorAlpha", "uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of(["// http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color\nfloat RGB2Luma(vec3 rgb) { return dot(rgb, vec3(0.212, 0.715, 0.072)); }\n// float RGB2Luma(vec3 rgb) { return dot(rgb, vec3(0.299, 0.587, 0.114)); }\n\nvoid main() {\n    vec4 color = texture(" + "uTexture" + ", " + "vTexUV" + ");\n    float luma = RGB2Luma(color.rgb);\n    float alpha = smoothstep(" + "uRange" + ".x, " + "uRange" + ".y, luma);\n    " + "oFragColor" + " = mix(" + "uColorAlpha" + ", color, alpha );\n}\n "]));
        return t0;
      })();
    },
    /*lib$.ColorFunctions*/get ColorFunctions() {
      return " // range is [0, 1] \n vec3 HUEtoRGB(float hue) {\n    float r = clamp(abs(hue * 6.0 - 3.0) - 1.0, 0.0, 1.0);\n    float g = clamp(2.0 - abs(hue * 6.0 - 2.0), 0.0, 1.0);\n    float b = clamp(2.0 - abs(hue * 6.0 - 4.0), 0.0, 1.0);\n    return vec3(r, g, b);\n }\n \n vec3 HSLtoRGB(vec3 HSL) {\n     vec3 RGB = HUEtoRGB(HSL.x);\n     float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n     return (RGB - 0.5) * C + HSL.z;\n  }\n";
    },
    set ColorFunctions(_) {},
    /*lib$.effectVertexShader*/get effectVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("null"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.NullVertexShaderString]));
        return t0;
      })();
    },
    /*lib$.copyVertexShader*/get copyVertexShader() {
      return lib$.effectVertexShader;
    },
    /*lib$.copyFragmentShader*/get copyFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("copyF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = texelFetch(" + "uTexture" + ", ivec2(gl_FragCoord.xy), 0);"]));
        return t0;
      })();
    },
    /*lib$.scalingCopyVertexShader*/get scalingCopyVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("nullUV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aTexUV"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.NullVertexShaderWithTextureForwardString]));
        return t0;
      })();
    },
    /*lib$.scalingCopyFragmentShader*/get scalingCopyFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("copyF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of(["oFragColor" + " = texture(" + "uTexture" + ", " + "vTexUV" + ");"]));
        return t0;
      })();
    },
    /*lib$._libFragment*/get _libFragment() {
      return "vec3 RGBtoHSV(vec3 rgb) {\n   float r = rgb.r;\n   float g = rgb.g;\n   float b = rgb.b;\n\n\n   float minv = min(min(r, g), b);\n   float maxv = max(max(r, g), b);\n   float delta = maxv - minv;\n\n   vec3 res;\n   res.z = maxv;            // v\n   if( maxv == 0.0 ) {\n      // r = g = b = 0      // s = 0, v is undefined\n      res.y = 0.0;\n      res.x = -1.0;\n      return res;\n   }\n\n   res.y = delta / maxv;      // s\n   if (r == maxv) res.x = (g - b) / delta;  // btwn yellow & magenta\n   else if (g == maxv) res.x = 2.0 + (b - r) / delta;   // btwn cyan & yellow\n   else res.x = 4.0 + (r - g) / delta;   // btwn magenta & cyan\n\n   res.x = res.x * 60.0;            // degrees\n   if( res.x < 0.0 ) res.x = res.x + 360.0;\n\n   return res;\n}\n\nvec3 HSVtoRGB(vec3 hsv) {\n   float h = hsv.x / 60.0;  // sector 0 to 5\n   float s = hsv.y;\n   float v = hsv.z;\n\n   if( s == 0.0 ) {\n      // achromatic (grey)\n      return vec3(v, v, v);\n   }\n\n   int i = int(floor( h ));\n   float f = h - float(i);         // fractional part of h\n   float p = v * ( 1.0 - s );\n   float q = v * ( 1.0 - s * f );\n   float t = v * ( 1.0 - s * ( 1.0 - f ) );\n\n   if (i == 0) return vec3(v, t, p);\n   else if (i == 1) return vec3(q, v , p);\n   else if (i == 2) return vec3(p, v, t);\n   else if (i == 3) return vec3(p, q, v);\n   else if (i == 4) return vec3(t, p, v);\n   return vec3(v, p, q);\n}\n";
    },
    /*lib$._toonFragment*/get _toonFragment() {
      return "\nvec3 config = vec3(1.0 / 80.0, 6.0, 3.0);\n// vec3 config = vec3(0.2, 2.0, 2.0);\n\n\n// averaged pixel intensity from 3 color channels\nfloat avg3(vec3 pix) {\n return (pix.r + pix.g + pix.b)/3.0;\n}\n\nvec3 get_pixel(ivec2 center, int dx, int dy) {\n return texelFetch(" + "uTexture" + ", center + ivec2(dx, dy), 0).rgb;\n}\n\n// returns pixel color using a strange kernel\n\nfloat IsEdge(ivec2 center) {\n  // read neighboring pixel intensities\n  float pix0 = avg3(get_pixel(center, -1, -1));\n  float pix1 = avg3(get_pixel(center, -1, 0));\n  float pix2 = avg3(get_pixel(center, -1, 1));\n  float pix3 = avg3(get_pixel(center, 0, -1));\n\n  float pix5 = avg3(get_pixel(center, 0, 1));\n  float pix6 = avg3(get_pixel(center, 1, -1));\n  float pix7 = avg3(get_pixel(center, 1, 0));\n  float pix8 = avg3(get_pixel(center, 1, 1));\n\n\n  // average color differences around neighboring pixels\n  float delta = (abs(pix1-pix7) + abs(pix5-pix3) +\n                 abs(pix0-pix8) + abs(pix2-pix6)) * 0.25;\n  return clamp(5.5*delta, 0.0, 1.0);\n}\n\nvoid main() {\n    ivec2 center = ivec2(gl_FragCoord.xy);\n\n    vec4 colorOrg = texelFetch(" + "uTexture" + ", center, 0);\n    vec3 vHSV =  RGBtoHSV(colorOrg.rgb);\n    // find nearest level\n    vHSV =  ceil(vHSV * config) / config;\n    float edg = IsEdge(center);\n    vec3 vRGB = (edg >= 0.3) ? vec3(0.0,0.0,0.0) : HSVtoRGB(vHSV);\n    //vec3 vRGB = (edg >= 0.3) ? vec3(1.0, 1.0, 1.0) : vec3(0.0, 0.0, 0.0);\n    //vec3 vRGB = HSVtoRGB(vHSV);\n    " + "oFragColor" + " = vec4(vRGB, 1.0);\n}\n";
    },
    set _toonFragment(_) {},
    /*lib$.toonFragmentShader*/get toonFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("ToonF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$._libFragment, lib$._toonFragment]));
        return t0;
      })();
    },
    /*lib$._hexPixelateFragment*/get _hexPixelateFragment() {
      return "\nfloat S = 0.86602540378;\n\nvec2 GetHexCenter(vec2 p) {\n vec2 a;\n    if (p.x + p.y - floor(p.x) - floor(p.y) < 1.0) a = vec2(floor(p.x), floor(p.y));\n    else a = vec2(ceil(p.x), ceil(p.y));\n    vec2 b = vec2(ceil(p.x), floor(p.y));\n    vec2 c = vec2(floor(p.x), ceil(p.y));\n\n    vec3 P = vec3(p.x, p.y, 1.0 - p.x - p.y);\n    vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n    vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n    vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n\n    float alen = length(P - A);\n    float blen = length(P - B);\n    float clen = length(P - C);\n\n    if (alen < blen) {\n        return (alen < clen) ? a : c;\n    } else {\n        return (blen < clen) ? b : c;\n    }\n}\n\nvec2 ToPixelSpace(vec2 v) {\n    vec2 p = (v - uCenter2) / uPointSize;\n    float t = p.y / S;\n    return vec2(p.x - 0.5 * t, t);\n}\n\nvec2 ToNormalizedSpace(vec2 v, vec2 texdim) {\n   vec2 p = vec2(v.x + v.y * 0.5, v.y * S);\n   return p * uPointSize + uCenter2 / texdim;\n}\n\nvoid main() {\n    vec2 texdim = vec2(textureSize(uTexture, 0));\n    vec2 p = ToPixelSpace(gl_FragCoord.xy);\n    vec2 c = GetHexCenter(p);\n    vec2 q = ToNormalizedSpace(c, texdim);\n    oFragColor = texelFetch(uTexture, ivec2(q), 0);\n}\n";
    },
    /*lib$.hexPixelateFragmentShader*/get hexPixelateFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("HexPixelateF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uCenter2", "uPointSize", "uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$._hexPixelateFragment]));
        return t0;
      })();
    },
    /*lib$.dotFragmentShader*/get dotFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("DotF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uCenter2", "uScale", "uAngle", "uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of(["// Inspired by three.js\n\nfloat pattern(vec2 tex) {\n\t\tfloat s = sin( " + "uAngle" + " );\n\t\tfloat c = cos( " + "uAngle" + " );\n\t\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * " + "uScale" + ";\n\t\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n}\n\nvoid main() {\n    vec2 center = gl_FragCoord.xy;\n\t\tvec2 texdim = vec2(textureSize(" + "uTexture" + ", 0));\n\t\tvec4 color = texelFetch(" + "uTexture" + ", ivec2(center), 0);\n\t\tfloat average = ( color.r + color.g + color.b ) / 3.0;\n    vec2 tex = center - " + "uCenter2" + ";\n\t\t" + "oFragColor" + " = vec4( vec3( average * 10.0 - 5.0 + pattern(tex) ), color.a );\n}\n"]));
        return t0;
      })();
    },
    /*lib$._tvDistortionFragment*/get _tvDistortionFragment() {
      return "float rand(vec2 co)  {\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt = dot(co.xy, vec2(a,b));\n    float sn = mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 rgbDistortion(vec2 uv, float magnitude, float time) {\n    // x offset for the three color channels\n    // we do not change the y\n\t  float dR = rand(vec2(time * 0.03, uv.y * 0.42)) * 0.001 +\n\t             sin(rand(vec2(time * 0.2, uv.y))) * magnitude;\n\t  float dG = rand(vec2(time * 0.004, uv.y * 0.002)) * 0.004 +\n               sin(time * 9.0) * magnitude;\n\t  float dB = 0.0;\n    return vec3(dR, dG, dB);\n}\n\nvoid main() {\n      vec2 dim = vec2(textureSize(uTexture, 0));\n      vec2 center = gl_FragCoord.xy / dim;\n      vec3 d = rgbDistortion(center, uScale, uTime);\n      float x = center.x;\n      float y = center.y;\n\n\t\t\tfloat r = texelFetch(uTexture, ivec2(dim * vec2(x + d.r, y)), 0).r;\n\t\t\tfloat g = texelFetch(uTexture, ivec2(dim * vec2(x + d.g, y)), 0).g;\n\t\t\tfloat b = texelFetch(uTexture, ivec2(dim * vec2(x + d.b, y)), 0).b;\n\t\t\toFragColor = vec4( r, g, b, 1.0 );\n}\n";
    },
    /*lib$.tvDistortionFragmentShader*/get tvDistortionFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("DotF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uScale", "uTime", "uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$._tvDistortionFragment]));
        return t0;
      })();
    },
    /*lib$.kaleidoscopeShader*/get kaleidoscopeShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("KaleidoscopeF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uScale", "uCenter2", "uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of(["vec2 kaleidoscope( vec2 uv, float n) {\n   float PI = 3.1415926;\n    float angle = PI / n;\n    float r = length(uv);\n\t  float a = atan( uv.y, uv.x ) / angle;\n\t  a = mix( fract( a ), 1.0 - fract( a ), mod( floor( a ), 2.0 ) ) * angle;\n\treturn vec2( cos( a ), sin( a ) ) * r;\n}\n\nvoid main() {\n    vec2 dim = vec2(textureSize(" + "uTexture" + ", 0));\n    vec2 p = gl_FragCoord.xy / dim;\n    vec2 uv = " + "uCenter2" + " + kaleidoscope(p - " + "uCenter2" + ", " + "uScale" + ");\n    " + "oFragColor" + " = texelFetch(" + "uTexture" + ", ivec2(uv * dim), 0);\n}\n"]));
        return t0;
      })();
    },
    /*lib$.lumidotsFragmentShader*/get lumidotsFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("LumidotsF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPointSize", "uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of(["// Inspired by https://www.shadertoy.com/view/MtcXRB\n\n// http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color\nfloat RGB2Luma(vec3 rgb) { return dot(rgb, vec3(0.212, 0.715, 0.072)); }\n// float RGB2Luma(vec3 rgb) { return dot(rgb, vec3(0.299, 0.587, 0.114)); }\n\n\nvoid main() {\n\t  vec2 texdim = vec2(textureSize(" + "uTexture" + ", 0));\n    float r = " + "uPointSize" + ";\n    vec2 uv = gl_FragCoord.xy;\n    vec2 center = floor(uv / r / 2.0) * 2.0 * r + r;\n    vec3 col = texelFetch(" + "uTexture" + ", ivec2(center), 0).rgb;\n    float lum = max(0.1, RGB2Luma(col));\n    float alpha =  smoothstep(1.0, 0.5,\n                              distance(center, uv) / lum / r);\n    " + "oFragColor" + ".rgb = col.rgb * alpha;\n}\n"]));
        return t0;
      })();
    },
    /*lib$.squarePixelateFragmentShader*/get squarePixelateFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("SquarePixelateF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPointSize", "uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of(["void main() {\n    float r = " + "uPointSize" + ";\n    vec2 center = floor(gl_FragCoord.xy / r / 2.0) * 2.0 * r + r;\n    " + "oFragColor" + " = texelFetch(" + "uTexture" + ", ivec2(center), 0);\n}\n"]));
        return t0;
      })();
    },
    /*lib$.luminosityHighPassFragmentShader*/get luminosityHighPassFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("LuminosityHighPassF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uRange", "uColorAlpha", "uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of(["// http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color\nfloat RGB2Luma(vec3 rgb) { return dot(rgb, vec3(0.212, 0.715, 0.072)); }\n// float RGB2Luma(vec3 rgb) { return dot(rgb, vec3(0.299, 0.587, 0.114)); }\n\nvoid main() {\n    vec4 color = texelFetch(" + "uTexture" + ", ivec2(gl_FragCoord.xy), 0);\n    float luma = RGB2Luma(color.rgb);\n    float alpha = smoothstep(" + "uRange" + ".x, " + "uRange" + ".y, luma);\n    " + "oFragColor" + " = mix(" + "uColorAlpha" + ", color, alpha );\n}\n "]));
        return t0;
      })();
    },
    /*lib$.fisheyeFragmentShader*/get fisheyeFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("FisheyePassF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of(["float fisheye_radius = 1.0;\n      \nvoid main() {\n    vec2 dim = vec2(textureSize(" + "uTexture" + ", 0));\n    vec2 pixel = gl_FragCoord.xy / dim;\n    float y = (pixel.y-0.5) * 2.0; // [0,1] => [-1, 1]\n\n    float angle = asin(y/fisheye_radius); // [-pi/2, pi/2]\n    float arc_length = angle * fisheye_radius;\n\n    float max_arc_length = asin(1.0 / fisheye_radius) * fisheye_radius;\n    float normalized_arc_length = (arc_length + max_arc_length) / \n                                  (max_arc_length * 2.0);\n    // set arc_length as y\n    vec2 uv = vec2(pixel.x, normalized_arc_length); \n    " + "oFragColor" + " = texelFetch(" + "uTexture" + ", ivec2(dim *uv), 0); \n}\n"]));
        return t0;
      })();
    },
    /*lib$.filmFragmentShader*/get filmFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("FilmPassF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of(["\nvec2 translation = vec2(0.1, 0.0);\nfloat frame = 1.0;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat vignette(vec2 uv) {\n    return min(1., 6000. * (uv.x * uv.y * (1. - uv.x) * (1. - uv.y) - pow(.2, 4.)));\n}\n\nfloat verticalNoise(vec2 uv) {\n    return rand(vec2(uv.x * 0.3242 + 1.4839, 1.));\n}\n\nfloat randomLines(vec2 uv, float a, float b, float c, float d) {\n    float discrete = floor(frame / 4.);\n    return step(0.0002 + 0.0005 * sin(discrete / a),\n            abs(uv.x - b + 0.05 * sin(discrete / c) * cos(discrete / d)));\n}\n\nvec3 scene(vec2 uv, vec2 pixel, vec2 dim) {\n    vec3 color = texelFetch(" + "uTexture" + ", ivec2(uv * dim), 0).rgb;\n    color += 0.1;\n    color *= vignette(uv);\n    color *= 0.9 + 0.1 * rand(uv);\n    color *= 0.95 + 0.05 * verticalNoise(pixel + floor(frame / 4.));\n    color = 0.5 * color + color * 0.5 * randomLines(uv, 28., 0.7, 33., 58.);\n    color = color * 0.8 + color * 0.2 * randomLines(uv, 47., 0.78, 61., 27.);\n    color = color * 0.7 + color * 0.3 * randomLines(uv, 31., 0.28, 79., 43.);\n    color = pow(max(vec3(0.),color), vec3(1.5));\n    color *= 0.8 + 0.4 * rand(vec2(floor(frame / 4.), 0.2));\n    return color;\n}\n\nvoid main() {\n    vec2 dim = vec2(textureSize(" + "uTexture" + ", 0));\n    vec2 pixel = gl_FragCoord.xy / dim;\n    vec2 uv = pixel;\n    uv += translation;\n    uv = vec2(pixel.x, mod(uv.y, 1.));\n    " + "oFragColor" + " = vec4(scene(uv, pixel, dim), 1.);\n}\n"]));
        return t0;
      })();
    },
    /*lib$.ConvolutionMatrixEmboss*/get ConvolutionMatrixEmboss() {
      return vector_math.Matrix3.new(-1.0, 0.0, -1.0, 0.0, 4.0, 0.0, -1.0, 0.0, -1.0);
    },
    /*lib$.ConvolutionOffsetEmboss*/get ConvolutionOffsetEmboss() {
      return vector_math.Vector3.new(0.5, 0.5, 0.5);
    },
    /*lib$.ConvolutionMatrixEmboss2*/get ConvolutionMatrixEmboss2() {
      return vector_math.Matrix3.new(2.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0);
    },
    /*lib$.ConvolutionOffsetEmboss2*/get ConvolutionOffsetEmboss2() {
      return vector_math.Vector3.new(0.5, 0.5, 0.5);
    },
    /*lib$.ConvolutionMatrixEngrave*/get ConvolutionMatrixEngrave() {
      return vector_math.Matrix3.new(-2.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 0.0);
    },
    /*lib$.ConvolutionOffsetEngrave*/get ConvolutionOffsetEngrave() {
      return vector_math.Vector3.new(0.37, 0.37, 0.37);
    },
    /*lib$.ConvolutionMatrixSharpen*/get ConvolutionMatrixSharpen() {
      let t0;
      return t0 = vector_math.Matrix3.new(0.0, -2.0, 0.0, -2.0, 11.0, -2.0, 0.0, -2.0, 0.0), (() => {
        t0.scale(0.333);
        return t0;
      })();
    },
    /*lib$.ConvolutionOffsetSharpen*/get ConvolutionOffsetSharpen() {
      return vector_math.Vector3.new(0.0, 0.0, 0.0);
    },
    /*lib$.ConvolutionMatrixEdges*/get ConvolutionMatrixEdges() {
      return vector_math.Matrix3.new(-1.0, -1.0, -1.0, -1.0, 8.0, -1.0, -1.0, -1.0, -1.0);
    },
    /*lib$.ConvolutionOffsetEdges*/get ConvolutionOffsetEdges() {
      return vector_math.Vector3.new(0.0, 0.0, 0.0);
    },
    /*lib$.ConvolutionMatrixBlur*/get ConvolutionMatrixBlur() {
      let t0;
      return t0 = vector_math.Matrix3.new(1.0, 2.0, 1.0, 2.0, 4.0, 2.0, 1.0, 2.0, 1.0), (() => {
        t0.scale(1.0 / 16.0);
        return t0;
      })();
    },
    /*lib$.ConvolutionOffsetBlur*/get ConvolutionOffsetBlur() {
      return vector_math.Vector3.new(0.0, 0.0, 0.0);
    },
    /*lib$.convolution3x3FragmentShader*/get convolution3x3FragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("Convolution3x3F"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uColor", "uConvolutionMatrix"]));
        t0.SetBody(T.JSArrayOfStringL().of(["void main() {\n    mat3 m = " + "uConvolutionMatrix" + ";\n    ivec2 center = ivec2(gl_FragCoord.xy);\n    vec3 sum = vec3(0.0, 0.0, 0.0);\n    for (int x = -1; x <= 1; x++) {\n      for (int y = -1; y <= 1; y++) {\n        sum += m[x+1][y+1] * texelFetch(" + "uTexture" + ", center + ivec2(x, y), 0).rgb;     \n      }\n    }\n    " + "oFragColor" + ".rgb = " + "uColor" + " + sum;\n}\n\n"]));
        return t0;
      })();
    },
    /*lib$.scanlineFragmentShader*/get scanlineFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("ScanlinePixelateF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uRange"]));
        t0.SetBody(T.JSArrayOfStringL().of(["      \n// const vec3 comp = vec3(0.05, 0.15, 0.95);\nconst vec3 comp = vec3(0.1, 0.30, 0.85);\n\nvoid main() {\n    // number scan lines: texture height * \n    vec2 sine_coord = " + "uRange" + " * 2.0 * 3.1415;\n                        \n    sine_coord.x = 0.0;\n    vec2 dim = vec2(textureSize(" + "uTexture" + ", 0));\n    vec2 pixel = gl_FragCoord.xy;\n    vec3 color =  texelFetch(" + "uTexture" + ", ivec2(pixel), 0).xyz;\n    float m = comp.z + \n              dot(comp.xy * sin(pixel / dim * sine_coord), vec2(1.0, 1.0));\n    " + "oFragColor" + " = vec4(color * m, 1.0);\n}\n"]));
        return t0;
      })();
    },
    /*lib$.waterFragmentShader*/get waterFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("WaterPixelateF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uTime"]));
        t0.SetBody(T.JSArrayOfStringL().of(["float wave(vec2 pos, float srcX, float srcY, float t) {\n   float dist = 300.0 * length(pos - vec2(srcX, srcY));\n   return sin(dist - 0.15 * t);\n}\n\nvoid main() {\n    vec2 center = gl_FragCoord.xy;\n    vec3 color = texelFetch(" + "uTexture" + ", ivec2(center), 0).rgb;\n    vec2 uv = center /  vec2(textureSize(" + "uTexture" + ", 0)); \n    float t =  " + "uTime" + " * 50.0;\n    float res = 0.0;\n    res += wave(uv, 0.6, 0.7, t);\n    res += wave(uv, 0.9, 0.9, t);\n    res += wave(uv, -0.6, 0.3, t);\n    res += wave(uv, 0.1, 0.4, t);\n    // res += wave(uv, 0.1, 0.4, t);\n    res += wave(uv, 0.5, 0.5, t);\n    res += wave(uv, -1.0, 1.4, t);\n    " + "oFragColor" + " = vec4(color * (0.9 + 0.012 * res), 1.0);\n}\n"]));
        return t0;
      })();
    },
    /*lib$.photoEffectHelper*/get photoEffectHelper() {
      return "\nvec3 SepiaColor(float gray, float sepiaFactor) {\n    vec3 sepiaColor = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n    vec3 one3 = vec3(1.0);\n    vec3 color = gray <= 0.5 ?\n                 sepiaColor * 2.0 * gray :\n                 one3 - 2.0 * (1.0 - gray) * (one3 - sepiaColor);\n\n    return vec3(gray) + sepiaFactor * (color - vec3(gray));\n}\n\n// additive blend of red and blue channels\nvec3 Technicolor1(vec3 inColor, float amount) {\t\n     vec2 bgFilter = vec2(1.0, 0.7);\n     float bg = dot(inColor.bg, bgFilter) * 0.5;\n     return mix(inColor, vec3(inColor.r, vec2(bg) * bgFilter), amount);\n}\n\n// multiplicative blend of red and blue channels\nvec3 Technicolor2(vec3 inColor, float amount) {\t\n    // TODO: simply this mess\n    vec3 redfilter       = vec3(1.0, 0.0, 0.0);\n    vec3 bluegreenfilter = vec3(0.0, 1.0, 1.0);\n    vec3 cyanfilter      = vec3(0.0, 1.0, 0.5);\n    vec3 magentafilter   = vec3(1.0, 0.0, 0.25);\n\n\t  vec3 redrecord       = inColor * redfilter;\n\t  vec3 bluegreenrecord = inColor * bluegreenfilter;\n\t\n\t  vec3 rednegative = vec3(redrecord.r);\n\t  vec3 bluegreennegative = vec3((bluegreenrecord.g + bluegreenrecord.b) * 0.5);\n\t\n\t  vec3 redoutput = rednegative + cyanfilter;\n\t  vec3 bluegreenoutput = bluegreennegative + magentafilter;\n\t\n\t  vec3 result = redoutput * bluegreenoutput;\n\t\n\t  return mix(inColor, result, amount);\n}\n\n//  matting between all channels.\nvec3 Technicolor3(vec3 inColor, float amount) {\t\t\n  vec3 matte = vec3(1.0) - inColor + (inColor.gbr + inColor.brg) * 0.5;\n \treturn mix(inColor, inColor * matte.gbr * matte.brg, amount);\n}\n\n// cyan, magenta, yellow and red/orange filters\nvec3 Technicolor4(vec3 inColor, float amount) {\t\t\n    // TODO: simply this mess\n    vec3 greenfilter     = vec3(0.0, 1.0, 0.0);\n    vec3 magentafilter   = vec3(1.0, 0.0, 1.0);\n    vec3 redorangefilter = vec3(0.99, 0.263, 0.0);\n    vec3 cyanfilter      = vec3(0.0, 1.0, 1.0);\n    vec3 yellowfilter    = vec3(1.0, 1.0, 0.0);\n    \n    vec3 greenrecord = inColor * greenfilter;\n\t  vec3 bluerecord  = inColor * magentafilter;\n    vec3 redrecord   = inColor * redorangefilter;\n    \n    vec3 rednegative   = vec3((redrecord.r + redrecord.g + redrecord.b) / 3.0);\n\t  vec3 greennegative = vec3((greenrecord.r + greenrecord.g + greenrecord.b) / 3.0);\n\t  vec3 bluenegative  = vec3((bluerecord.r + bluerecord.g + bluerecord.b ) / 3.0);\n\t\n\t  vec3 redoutput   = rednegative + cyanfilter;\n\t  vec3 greenoutput = greennegative + magentafilter;\n\t  vec3 blueoutput  =  bluenegative + yellowfilter;\n\t\n\t  vec3 result = redoutput * greenoutput * blueoutput;\n    return mix(inColor, result, amount);\n}\n\nfloat VignettingFactor(vec2 uv, float innerRadius, float outerRadius) {\t\t\n\tfloat d = distance(vec2(0.5, 0.5), uv) * 1.414213;\n\treturn clamp((outerRadius - d) / (outerRadius - innerRadius), 0.0, 1.0);\n}\n";
    },
    /*lib$.sepiaFragmentShader*/get sepiaFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("sepiaPixelateF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uScale"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.photoEffectHelper, "void main() { \n    vec3 color = texelFetch(" + "uTexture" + ", ivec2(gl_FragCoord.xy), 0).rgb;\n    float gray = dot(color, vec3(0.3333));\n    // float gray = dot(color, vec3(0.2126, 0.7152, 0.0723));\n    " + "oFragColor" + " = vec4(SepiaColor(gray, " + "uScale" + "), 1.0);\n}\n"]));
        return t0;
      })();
    },
    /*lib$.techicolorFragmentShader*/get techicolorFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("technicolorPixelateF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.photoEffectHelper, "void main() { \n    vec3 color = texelFetch(" + "uTexture" + ", ivec2(gl_FragCoord.xy), 0).rgb;\n    " + "oFragColor" + " = vec4(Technicolor3(color, 0.5), 1.0);\n}\n"]));
        return t0;
      })();
    },
    /*lib$.vignettingFragmentShader*/get vignettingFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("vignettingPixelateF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uRange"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.photoEffectHelper, "void main() { \n    vec2 dim = vec2(textureSize(" + "uTexture" + ", 0));\n    vec3 color = texelFetch(" + "uTexture" + ", ivec2(gl_FragCoord.xy), 0).rgb;\n    float v = VignettingFactor(gl_FragCoord.xy / dim, " + "uRange" + ".x, " + "uRange" + ".y);\n    " + "oFragColor" + " = vec4(color * v, 1.0);\n}\n"]));
        return t0;
      })();
    },
    /*lib$.blur1DShader9*/get blur1DShader9() {
      let t0;
      return t0 = new lib.ShaderObject.new("blurF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uDirection"]));
        t0.SetBody(T.JSArrayOfStringL().of(["void main() { \n    vec4 sum = vec4(0.0);\n    vec2 c = gl_FragCoord.xy;\n    vec2 d = " + "uDirection" + ";\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c - 4.0 * d), 0) * 0.0510;\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c - 3.0 * d), 0) * 0.0918;\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c - 2.0 * d), 0) * 0.1224;\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c - 1.0 * d), 0) * 0.1531;\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c)          , 0) * 0.1633;\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c + 1.0 * d), 0) * 0.1531;\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c + 2.0 * d), 0) * 0.1224;\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c + 3.0 * d), 0) * 0.0918;\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c + 4.0 * d), 0) * 0.0510;\n    " + "oFragColor" + " = sum;\n}\n"]));
        return t0;
      })();
    },
    /*lib$.blur1DShader7*/get blur1DShader7() {
      let t0;
      return t0 = new lib.ShaderObject.new("blurF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uDirection"]));
        t0.SetBody(T.JSArrayOfStringL().of(["void main() { \n    vec4 sum = vec4(0.0);\n    vec2 c = gl_FragCoord.xy;\n    vec2 d = " + "uDirection" + ";\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c - 3.0 * d), 0) * (1.0 / 64.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c - 2.0 * d), 0) * (6.0 / 64.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c - 1.0 * d), 0) * (15.0 / 64.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c)          , 0) * (20.0 / 64.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c + 1.0 * d), 0) * (15.0 / 64.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c + 2.0 * d), 0) * (6.0 / 64.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c + 3.0 * d), 0) * (1.0 / 64.0);\n    " + "oFragColor" + " = sum;\n}\n"]));
        return t0;
      })();
    },
    /*lib$.blur1DShader5*/get blur1DShader5() {
      let t0;
      return t0 = new lib.ShaderObject.new("blurF"), (() => {
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uDirection"]));
        t0.SetBody(T.JSArrayOfStringL().of(["void main() { \n    vec4 sum = vec4(0.0);\n    vec2 c = gl_FragCoord.xy;\n    vec2 d = " + "uDirection" + ";\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c - 2.0 * d), 0) * (1.0 / 16.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c - 1.0 * d), 0) * (4.0 / 16.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c)          , 0) * (6.0 / 16.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c + 1.0 * d), 0) * (4.0 / 16.0);\n    sum  += texelFetch(" + "uTexture" + ", ivec2(c + 2.0 * d), 0) * (1.0 / 16.0);\n    " + "oFragColor" + " = sum;\n}\n"]));
        return t0;
      })();
    },
    /*lib$._VertexShaderPlane2ColorV*/get _VertexShaderPlane2ColorV() {
      return "vec3 HSV2RGB( vec3 hsv )\n{\n    hsv.x = mod( 100.0 + hsv.x, 1.0 ); // Ensure [0,1[\n    float   HueSlice = 6.0 * hsv.x; // In [0,6[\n    float   HueSliceInteger = floor( HueSlice );\n    float   HueSliceInterpolant = HueSlice - HueSliceInteger; // In [0,1[ for each hue slice\n    vec3  TempRGB = vec3(   hsv.z * (1.0 - hsv.y), hsv.z * (1.0 - hsv.y * HueSliceInterpolant), hsv.z * (1.0 - hsv.y * (1.0 - HueSliceInterpolant)) );\n    float   IsOddSlice = mod( HueSliceInteger, 2.0 ); // 0 if even (slices 0, 2, 4), 1 if odd (slices 1, 3, 5)\n    float   ThreeSliceSelector = 0.5 * (HueSliceInteger - IsOddSlice); // (0, 1, 2) corresponding to slices (0, 2, 4) and (1, 3, 5)\n    vec3  ScrollingRGBForEvenSlices = vec3( hsv.z, TempRGB.zx );           // (V, Temp Blue, Temp Red) for even slices (0, 2, 4)\n    vec3  ScrollingRGBForOddSlices = vec3( TempRGB.y, hsv.z, TempRGB.x );  // (Temp Green, V, Temp Red) for odd slices (1, 3, 5)\n    vec3  ScrollingRGB = mix( ScrollingRGBForEvenSlices, ScrollingRGBForOddSlices, IsOddSlice );\n    float   IsNotFirstSlice = clamp( ThreeSliceSelector, 0.0,1.0 ); // 1 if NOT the first slice (true for slices 1 and 2)\n    float   IsNotSecondSlice = clamp( ThreeSliceSelector-1.0, 0.0,1. ); // 1 if NOT the first or second slice (true only for slice 2)\n    return  mix( ScrollingRGB.xyz, mix( ScrollingRGB.zxy, ScrollingRGB.yzx, IsNotSecondSlice ), IsNotFirstSlice ); // Make the RGB rotate right depending on final slice index\n}\n\nvoid main(void) {\n  gl_Position = uPerspectiveViewMatrix * uModelMatrix * vec4(aPosition, 1.0);\n  float d=dot( aPosition, aNormal);\n  vec3 hsv = vec3(d,1,1);\n  vColor = HSV2RGB(hsv);\n}\n";
    },
    /*lib$.ssaoVertexShader*/get ssaoVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("SSAOV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aTexUV"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.NullVertexShaderWithTextureForwardString]));
        return t0;
      })();
    },
    /*lib$.ssaoFragmentShader*/get ssaoFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("SSAOF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uCanvasSize", "uCameraNear", "uCameraFar", "uTexture", "uDepthMap"]));
        t0.SetBody(T.JSArrayOfStringL().of(["\n    //uniform bool fogEnabled;\n    const bool fogEnabled=false;\n\n    //uniform bool onlyAO;\n    const bool onlyAO=false;\n\n\n    //uniform float aoClamp;\n    const float aoClamp = 0.45;\n\n    //uniform float lumInfluence;\n    const float lumInfluence = 0.4;\n\n    //varying vec2 vUv;\n    \n    #define DL 2.399963229728653\n    #define EULER 2.718281828459045\n    \n\n\n    const int samples = 8;\n    const float radius = 5.0;\n    const bool useNoise = false;\n    const float noiseAmount = 0.0003;\n    const float diffArea = 0.4;\n    const float gDisplace = 0.4;\n    const vec3 onlyAOColor = vec3( 1.0, 0.7, 0.5 );\n    \n    float unpackDepth( const in vec4 rgba_depth ) {\n      return rgba_depth.r;\n    }\n\n    float unpackDepth2(vec4 rgba_depth) {\n      const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n      float depth = dot( rgba_depth, bit_shift );\n      return depth;\n    }\n    \n    vec2 rand( const vec2 coord ) {\n      vec2 noise;\n      if ( useNoise ) {\n        float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\n        float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\n        noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\n      } else {\n        float width = " + "uCanvasSize" + ".x;\n        float height = " + "uCanvasSize" + ".y;\n        float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );\n        float gg = fract( coord.t * ( height / 2.0 ) );\n        noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\n      }\n      return ( noise * 2.0  - 1.0 ) * noiseAmount;\n    }\n    \n/*\n    float doFog() {\n      float zdepth = unpackDepth( texture(" + "uDepthMap" + ", " + "vTexUV" + " ) );\n      float depth = -cameraFar * cameraNear / ( zdepth * cameraFarMinusNear - cameraFar );\n      return smoothstep( fogNear, fogFar, depth );\n    }\n*/  \n\n    float readDepth(vec2 coord) {\n      float cameraFarPlusNear = " + "uCameraFar" + " + " + "uCameraNear" + ";\n      float cameraFarMinusNear = " + "uCameraFar" + " - " + "uCameraNear" + ";\n      float cameraCoef = 2.0 * " + "uCameraNear" + ";\n      return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture(" + "uDepthMap" + ", coord ) ) * cameraFarMinusNear );\n    }\n    \n    float compareDepths( const in float depth1, const in float depth2, inout int far ) {\n      float garea = 2.0;\n      float diff = ( depth1 - depth2 ) * 100.0;\n      if ( diff < gDisplace ) {\n        garea = diffArea;\n      } else {\n        far = 1;\n      }\n    \n      float dd = diff - gDisplace;\n      float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\n      return gauss;\n    }\n    \n    float calcAO( float depth, float dw, float dh ) {\n      float dd = radius - depth * radius;\n      vec2 vv = vec2( dw, dh );\n      vec2 coord1 = " + "vTexUV" + " + dd * vv;\n      vec2 coord2 = " + "vTexUV" + " - dd * vv;\n      float temp1 = 0.0;\n      float temp2 = 0.0;\n      int far = 0;\n      temp1 = compareDepths( depth, readDepth( coord1 ), far );\n      if ( far > 0 ) {\n        temp2 = compareDepths( readDepth( coord2 ), depth, far );\n        temp1 += ( 1.0 - temp1 ) * temp2;\n      }\n      return temp1;\n    }\n    \n    void main() {\n      float width = " + "uCanvasSize" + ".x;\n      float height = " + "uCanvasSize" + ".y;\n\n      vec2 noise = rand( " + "vTexUV" + " );\n      float depth = readDepth( " + "vTexUV" + " );\n      float tt = clamp( depth, aoClamp, 1.0 );\n      float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );\n      float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );\n      float pw;\n      float ph;\n      float ao;\n      float dz = 1.0 / float( samples );\n      float z = 1.0 - dz / 2.0;\n      float l = 0.0;\n      for ( int i = 0; i <= samples; i ++ ) {\n        float r = sqrt( 1.0 - z );\n        pw = cos( l ) * r;\n        ph = sin( l ) * r;\n        ao += calcAO( depth, pw * w, ph * h );\n        z = z - dz;\n        l = l + DL;\n      }\n    \n      ao /= float( samples );\n      ao = 1.0 - ao;\n\n/*\n      if ( fogEnabled ) {\n        ao = mix( ao, 1.0, doFog() );\n      }\n*/\n\n      // Diffuse\n      vec3 color = texture(" + "uTexture" + ", " + "vTexUV" + " ).rgb;\n      vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\n      float lum = dot( color.rgb, lumcoeff );\n      vec3 luminance = vec3( lum );\n      vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\n    \n      if ( onlyAO ) {\n        final = onlyAOColor * vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\n      }\n      " + "oFragColor" + " = vec4( final, 1.0 );\n      //" + "oFragColor" + " = vec4( color, 1.0 );\n    }\n    \n    "]));
        return t0;
      })();
    },
    /*lib$.sobelVertexShader*/get sobelVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("SobelV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aTexUV"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.NullVertexShaderWithTextureForwardString]));
        return t0;
      })();
    },
    /*lib$.sobelFragmentShader*/get sobelFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("SobelF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vTexUV"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uTexture", "uCanvasSize"]));
        t0.SetBody(T.JSArrayOfStringL().of(["  float lum(vec4 c) {\n    return dot(c.xyz, vec3(0.3, 0.59, 0.11));\n  }\n\n  float sobel() {\n      vec2 imageIncrement = vec2(1.0/" + "uCanvasSize" + ".x,1.0/" + "uCanvasSize" + ".y);\n      float t00 = lum(texture(" + "uTexture" + ", " + "vTexUV" + " + imageIncrement * vec2(-1, -1)));\n      float t10 = lum(texture(" + "uTexture" + ", " + "vTexUV" + " + imageIncrement * vec2( 0, -1)));\n      float t20 = lum(texture(" + "uTexture" + ", " + "vTexUV" + " + imageIncrement * vec2( 1, -1)));\n      float t01 = lum(texture(" + "uTexture" + ", " + "vTexUV" + " + imageIncrement * vec2(-1,  0)));\n      float t21 = lum(texture(" + "uTexture" + ", " + "vTexUV" + " + imageIncrement * vec2( 1,  0)));\n      float t02 = lum(texture(" + "uTexture" + ", " + "vTexUV" + " + imageIncrement * vec2(-1,  1)));\n      float t12 = lum(texture(" + "uTexture" + ", " + "vTexUV" + " + imageIncrement * vec2( 0,  1)));\n      float t22 = lum(texture(" + "uTexture" + ", " + "vTexUV" + " + imageIncrement * vec2( 1,  1)));\n       // sobel kernel used\n       // x:\n       // +1  0 -1\n       // +2  0 -2\n       // +1  0 -1\n       // \n       // y:\n       // +1  +2 +1\n       //  0   0  0\n       // -1  -2 -1\n      vec2 grad;\n      grad.x = t00 + 2.0 * t01 + t02 - t20 - 2.0 * t21 - t22;\n      grad.y = t00 + 2.0 * t10 + t20 - t02 - 2.0 * t12 - t22;\n      return length(grad);\n  } \n\n  void main(void) {\n      float len = sobel();\n      " + "oFragColor" + " = vec4(len, len, len, 1.0); //\n  }\n  "]));
        return t0;
      })();
    },
    /*lib$.PerlinNoiseFunctions*/get PerlinNoiseFunctions() {
      return "vec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n";
    },
    /*lib$.perlinNoiseVertexShader*/get perlinNoiseVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("PerlinNoiseV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vNormal"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix", "uTime"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$.PerlinNoiseFunctions, "void main() {\n    " + "vNormal" + " = normalize( " + "aPosition" + ");\n    gl_Position = " + "uPerspectiveViewMatrix" + " * " + "uModelMatrix" + " * vec4(" + "aPosition" + ", 1.0);\n}\n"]));
        return t0;
      })();
    },
    /*lib$.SimplexNoiseHelpers*/get SimplexNoiseHelpers() {
      return "vec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n";
    },
    /*lib$.SimplexNoiseFunction2*/get SimplexNoiseFunction2() {
      return "float snoise2(vec2 v) {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n";
    },
    /*lib$.SimplexNoiseFunction3*/get SimplexNoiseFunction3() {
      return "float snoise3(vec3 v) { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n";
    },
    /*lib$._WireframeF*/get _WireframeF() {
      return "// the 3 vertices of a Face3 (w == 0) have the centers:\n// (1, 0, 0, 0)) \n// (0, 1, 0, 0)\n// (0, 0, 1, 0)\nfloat edgeFactorFace3(vec3 center) {\n    vec3 d = fwidth(center);\n    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, center);\n    return min(min(a3.x, a3.y), a3.z);\n}\n\n// the 4 vertices of a Face4 (w == 1) have the centers:\n// (1, 0, 0, 1) \n// (1, 1, 0, 1)\n// (0, 1, 0, 1)\n// (0, 0, 0, 1)\nfloat edgeFactorFace4(vec2 center) {\n    vec2 d = fwidth(center);\n    vec2 a2 = smoothstep(vec2(0.0), d * 1.5, center);\n    return min(a2.x, a2.y);\n}\n\nvoid main() {\n    float q;\n    if (vCenter.w == 0.0) {\n        q = edgeFactorFace3(vCenter.xyz);\n    } else {\n        q = min(edgeFactorFace4(vCenter.xy),\n                edgeFactorFace4(1.0 - vCenter.xy));\n    }\n    oFragColor = mix(uColorAlpha, uColorAlpha2, q);\n}\n";
    },
    /*lib$.wireframeVertexShader*/get wireframeVertexShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("WireframeV"), (() => {
        t0.AddAttributeVars(T.JSArrayOfStringL().of(["aPosition", "aCenter"]));
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vCenter"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uPerspectiveViewMatrix", "uModelMatrix"]));
        t0.SetBodyWithMain(T.JSArrayOfStringL().of([lib$.StdVertexBody, "vCenter" + " = " + "aCenter" + ";"]));
        return t0;
      })();
    },
    /*lib$.wireframeFragmentShader*/get wireframeFragmentShader() {
      let t0;
      return t0 = new lib.ShaderObject.new("WireframeF"), (() => {
        t0.AddVaryingVars(T.JSArrayOfStringL().of(["vCenter"]));
        t0.AddUniformVars(T.JSArrayOfStringL().of(["uColorAlpha", "uColorAlpha2"]));
        t0.SetBody(T.JSArrayOfStringL().of([lib$._WireframeF]));
        return t0;
      })();
    }
  }, true);
  dart.trackLibraries("packages/flutter_wgl/src/shader/lib.dart", {
    "package:flutter_wgl/src/shader/lib.dart": lib$
  }, {
    "package:flutter_wgl/src/shader/lib.dart": ["fragment.dart", "simple_shaders.dart", "basic_shader.dart", "blur_shader.dart", "color_helpers.dart", "effect_shaders.dart", "plane_shader.dart", "ssao_shader.dart", "sobel_shader.dart", "perlin_noise_helpers.dart", "perlin_noise_shader.dart", "simplex_noise_helper.dart", "wireframe_shader.dart", "standard.dart"]
  }, '{"version":3,"sourceRoot":"","sources":["blur_shader.dart","effect_shaders.dart","perlin_noise_shader.dart","plane_shader.dart","fragment.dart","simple_shaders.dart","basic_shader.dart","color_helpers.dart","ssao_shader.dart","sobel_shader.dart","perlin_noise_helpers.dart","simplex_noise_helper.dart","wireframe_shader.dart"],"names":[],"mappings":"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","file":"../../../../../../../../../../Z:/packages/flutter_wgl/src/shader/lib.dart.lib.js"}');
  // Exports:
  return {
    src__shader__lib: lib$
  };
}));

//# sourceMappingURL=lib.dart.lib.js.map
